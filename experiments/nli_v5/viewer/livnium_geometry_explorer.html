<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livnium Geometry Explorer - The REAL 3D Structure</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: white;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-bottom: 2px solid #4fc3f7;
            z-index: 100;
        }
        
        #header h1 {
            font-size: 24px;
            color: #4fc3f7;
            margin-bottom: 5px;
        }
        
        #header p {
            font-size: 12px;
            color: #b0bec5;
        }
        
        #main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        #control-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        #control-panel h2 {
            font-size: 16px;
            color: #4fc3f7;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-section {
            margin-bottom: 25px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #b0bec5;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }
        
        select option {
            background: #1a1a2e;
            color: white;
        }
        
        .toggle-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .toggle-btn {
            background: rgba(79, 195, 247, 0.2);
            border: 1px solid #4fc3f7;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            flex: 1;
            min-width: 80px;
        }
        
        .toggle-btn:hover {
            background: rgba(79, 195, 247, 0.4);
        }
        
        .toggle-btn.active {
            background: #4fc3f7;
            color: #0a0a0a;
            font-weight: bold;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #4fc3f7;
            font-weight: bold;
        }
        
        #viewer-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
        }
        
        #plot-container {
            width: 100%;
            height: 100%;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-text {
            font-size: 11px;
            color: #81d4fa;
            line-height: 1.6;
            margin-top: 10px;
            padding: 10px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ðŸ”· Livnium Geometry Explorer</h1>
            <p>The REAL 3D Force Field Inside the Cube - Not a Projection, Not a Sphere</p>
        </div>
        
        <div id="main-content">
            <div id="control-panel">
                <div class="control-section">
                    <h2>View Mode</h2>
                    <div class="toggle-group">
                        <button class="toggle-btn active" onclick="setViewMode('vector')">Vector Field</button>
                        <button class="toggle-btn" onclick="setViewMode('volume')">Volume MRI</button>
                        <button class="toggle-btn" onclick="setViewMode('isosurface')">Isosurface</button>
                    </div>
                    <div class="info-text" id="viewModeInfo">
                        <strong>Vector Field:</strong> Shows force directions as arrows. Blue = inward (entailment), Red = outward (contradiction).
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>Field Selection</h2>
                    <div class="control-group">
                        <label>Display Field</label>
                        <select id="fieldSelect" onchange="updateVisualization()">
                            <option value="divergence">Divergence (Push/Pull)</option>
                            <option value="resonance">Resonance (Similarity)</option>
                            <option value="curvature">Curvature (Stability)</option>
                            <option value="stability">Stability (Valley Depth)</option>
                            <option value="cold_force">Cold Force (Entailment)</option>
                            <option value="far_force">Far Force (Contradiction)</option>
                        </select>
                    </div>
                </div>
                
                <div class="control-section" id="vectorControls">
                    <h2>Vector Field Options</h2>
                    <div class="control-group">
                        <label>Arrow Density: <span id="arrowDensityValue" class="range-value">5</span></label>
                        <input type="range" id="arrowDensity" min="2" max="10" value="5" step="1" oninput="updateArrowDensity()">
                    </div>
                    <div class="control-group">
                        <label>Arrow Scale: <span id="arrowScaleValue" class="range-value">1.0</span></label>
                        <input type="range" id="arrowScale" min="0.1" max="3.0" value="1.0" step="0.1" oninput="updateArrowScale()">
                    </div>
                </div>
                
                <div class="control-section" id="volumeControls" style="display: none;">
                    <h2>Volume Rendering</h2>
                    <div class="control-group">
                        <label>Slice Depth (Z): <span id="sliceDepthValue" class="range-value">0.0</span></label>
                        <input type="range" id="sliceDepth" min="-1" max="1" value="0" step="0.1" oninput="updateSliceDepth()">
                    </div>
                    <div class="control-group">
                        <label>Opacity: <span id="opacityValue" class="range-value">0.5</span></label>
                        <input type="range" id="opacity" min="0.1" max="1.0" value="0.5" step="0.1" oninput="updateOpacity()">
                    </div>
                </div>
                
                <div class="control-section" id="isosurfaceControls" style="display: none;">
                    <h2>Isosurface</h2>
                    <div class="control-group">
                        <label>Isovalue: <span id="isovalueValue" class="range-value">0.5</span></label>
                        <input type="range" id="isovalue" min="0" max="1" value="0.5" step="0.05" oninput="updateIsosurface()">
                    </div>
                </div>
                
                <div class="control-section">
                    <h2>Display Options</h2>
                    <div class="toggle-group">
                        <button class="toggle-btn" onclick="resetView()">Reset Camera</button>
                        <button class="toggle-btn" onclick="toggleCube()">Toggle Cube</button>
                    </div>
                </div>
            </div>
            
            <div id="viewer-container">
                <div id="loading">
                    <div class="spinner"></div>
                    <div>Loading REAL Livnium Geometry...</div>
                </div>
                <div id="plot-container"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let forceFieldData = null;
        let currentViewMode = 'vector';
        let currentField = 'divergence';
        let arrowDensity = 5;
        let arrowScale = 1.0;
        let sliceDepth = 0.0;
        let opacity = 0.5;
        let isovalue = 0.5;
        let showCube = true;
        
        // Load force field data
        async function loadForceFieldData() {
            try {
                const response = await fetch('../planet_output/livnium_3d_force_field.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                console.log('Force field data loaded:', data.metadata);
                return data;
            } catch (error) {
                console.error('Error loading force field data:', error);
                alert('Failed to load force field data.\n\nPlease run:\npython3 planet/compute_3d_force_field.py');
                return null;
            }
        }
        
        // Initialize
        async function init() {
            forceFieldData = await loadForceFieldData();
            if (!forceFieldData) {
                document.getElementById('loading').innerHTML = 
                    '<div class="spinner"></div>' +
                    '<div>Failed to load data. Check console.</div>';
                return;
            }
            
            document.getElementById('loading').style.display = 'none';
            updateVisualization();
        }
        
        // Set view mode
        function setViewMode(mode) {
            currentViewMode = mode;
            
            // Update UI
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                if (btn.textContent.includes('Vector') || btn.textContent.includes('Volume') || btn.textContent.includes('Isosurface')) {
                    btn.classList.remove('active');
                }
            });
            event.target.classList.add('active');
            
            // Show/hide controls
            document.getElementById('vectorControls').style.display = mode === 'vector' ? 'block' : 'none';
            document.getElementById('volumeControls').style.display = mode === 'volume' ? 'block' : 'none';
            document.getElementById('isosurfaceControls').style.display = mode === 'isosurface' ? 'block' : 'none';
            
            // Update info text
            const infoTexts = {
                'vector': '<strong>Vector Field:</strong> Shows force directions as arrows. Blue = inward (entailment), Red = outward (contradiction).',
                'volume': '<strong>Volume MRI:</strong> Shows density of forces like a CT scan. Slice through the cube to see internal structure.',
                'isosurface': '<strong>Isosurface:</strong> Shows the actual topological shape where the field equals a constant value. This is the REAL shape of Livnium.'
            };
            document.getElementById('viewModeInfo').innerHTML = infoTexts[mode];
            
            updateVisualization();
        }
        
        // Update visualization
        function updateVisualization() {
            if (!forceFieldData) return;
            
            currentField = document.getElementById('fieldSelect').value;
            
            switch (currentViewMode) {
                case 'vector':
                    renderVectorField();
                    break;
                case 'volume':
                    renderVolume();
                    break;
                case 'isosurface':
                    renderIsosurface();
                    break;
            }
        }
        
        // Render vector field
        function renderVectorField() {
            const coords = forceFieldData.coordinates;
            const forces = forceFieldData.forces;
            const field = forceFieldData.fields[currentField];
            
            // Sample points based on density
            const step = Math.max(1, Math.floor(Math.sqrt(coords.x.length) / arrowDensity));
            const sampled = [];
            
            for (let i = 0; i < coords.x.length; i += step) {
                sampled.push({
                    x: coords.x[i],
                    y: coords.y[i],
                    z: coords.z[i],
                    u: forces.x[i] * arrowScale,
                    v: forces.y[i] * arrowScale,
                    w: forces.z[i] * arrowScale,
                    magnitude: forces.magnitude[i],
                    fieldValue: field.normalized[i]
                });
            }
            
            // Prepare data
            const x = sampled.map(s => s.x);
            const y = sampled.map(s => s.y);
            const z = sampled.map(s => s.z);
            const u = sampled.map(s => s.u);
            const v = sampled.map(s => s.v);
            const w = sampled.map(s => s.w);
            const colors = sampled.map(s => {
                // Color by divergence: blue (negative) to red (positive)
                const val = s.fieldValue;
                if (val < 0.33) return `rgb(50, 100, 200)`;  // Blue (inward)
                if (val < 0.66) return `rgb(150, 150, 150)`;  // Gray (neutral)
                return `rgb(200, 50, 50)`;  // Red (outward)
            });
            
            const trace = {
                type: 'cone',
                x: x,
                y: y,
                z: z,
                u: u,
                v: v,
                w: w,
                colorscale: [[0, 'rgb(50, 100, 200)'], [0.5, 'rgb(150, 150, 150)'], [1, 'rgb(200, 50, 50)']],
                sizemode: 'absolute',
                sizeref: 0.1,
                anchor: 'tail',
                showscale: true,
                colorbar: { title: currentField }
            };
            
            const layout = {
                scene: {
                    xaxis: { title: 'X', backgroundcolor: 'rgba(0,0,0,0)' },
                    yaxis: { title: 'Y', backgroundcolor: 'rgba(0,0,0,0)' },
                    zaxis: { title: 'Z', backgroundcolor: 'rgba(0,0,0,0)' },
                    bgcolor: 'rgba(0,0,0,0)',
                    camera: {
                        eye: { x: 1.5, y: 1.5, z: 1.5 }
                    }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { l: 0, r: 0, t: 0, b: 0 }
            };
            
            if (showCube) {
                // Add cube wireframe
                const cubeSize = 1.0;
                const cubeTrace = {
                    type: 'scatter3d',
                    mode: 'lines',
                    x: [-cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize],
                    y: [-cubeSize, -cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, cubeSize, cubeSize],
                    z: [-cubeSize, -cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, cubeSize, cubeSize, -cubeSize, cubeSize, cubeSize, -cubeSize, -cubeSize, cubeSize, cubeSize, -cubeSize],
                    line: { color: 'rgba(79, 195, 247, 0.3)', width: 2 },
                    showlegend: false
                };
                Plotly.newPlot('plot-container', [cubeTrace, trace], layout);
            } else {
                Plotly.newPlot('plot-container', [trace], layout);
            }
        }
        
        // Render volume (simplified - using slice)
        function renderVolume() {
            const coords = forceFieldData.coordinates;
            const field = forceFieldData.fields[currentField];
            const resolution = forceFieldData.metadata.resolution;
            
            // Create slice at specified depth
            const sliceZ = sliceDepth;
            const tolerance = 0.1;
            
            const slicePoints = [];
            for (let i = 0; i < coords.z.length; i++) {
                if (Math.abs(coords.z[i] - sliceZ) < tolerance) {
                    slicePoints.push({
                        x: coords.x[i],
                        y: coords.y[i],
                        z: coords.z[i],
                        value: field.normalized[i]
                    });
                }
            }
            
            if (slicePoints.length === 0) {
                console.warn('No points found for slice');
                return;
            }
            
            const x = slicePoints.map(p => p.x);
            const y = slicePoints.map(p => p.y);
            const z = slicePoints.map(p => p.z);
            const values = slicePoints.map(p => p.value);
            
            const trace = {
                type: 'scatter3d',
                mode: 'markers',
                x: x,
                y: y,
                z: z,
                marker: {
                    size: 5,
                    color: values,
                    colorscale: 'Viridis',
                    opacity: opacity,
                    showscale: true,
                    colorbar: { title: currentField }
                }
            };
            
            const layout = {
                scene: {
                    xaxis: { title: 'X' },
                    yaxis: { title: 'Y' },
                    zaxis: { title: 'Z' },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };
            
            Plotly.newPlot('plot-container', [trace], layout);
        }
        
        // Render isosurface (simplified - using threshold)
        function renderIsosurface() {
            const coords = forceFieldData.coordinates;
            const field = forceFieldData.fields[currentField];
            
            // Find points near isovalue
            const tolerance = 0.05;
            const isosurfacePoints = [];
            
            for (let i = 0; i < field.normalized.length; i++) {
                if (Math.abs(field.normalized[i] - isovalue) < tolerance) {
                    isosurfacePoints.push({
                        x: coords.x[i],
                        y: coords.y[i],
                        z: coords.z[i],
                        value: field.normalized[i]
                    });
                }
            }
            
            if (isosurfacePoints.length === 0) {
                console.warn('No points found for isosurface');
                return;
            }
            
            const x = isosurfacePoints.map(p => p.x);
            const y = isosurfacePoints.map(p => p.y);
            const z = isosurfacePoints.map(p => p.z);
            
            const trace = {
                type: 'scatter3d',
                mode: 'markers',
                x: x,
                y: y,
                z: z,
                marker: {
                    size: 3,
                    color: 'rgb(79, 195, 247)',
                    opacity: 0.6
                }
            };
            
            const layout = {
                scene: {
                    xaxis: { title: 'X' },
                    yaxis: { title: 'Y' },
                    zaxis: { title: 'Z' },
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)'
            };
            
            Plotly.newPlot('plot-container', [trace], layout);
        }
        
        // Control functions
        function updateArrowDensity() {
            arrowDensity = parseInt(document.getElementById('arrowDensity').value);
            document.getElementById('arrowDensityValue').textContent = arrowDensity;
            if (currentViewMode === 'vector') updateVisualization();
        }
        
        function updateArrowScale() {
            arrowScale = parseFloat(document.getElementById('arrowScale').value);
            document.getElementById('arrowScaleValue').textContent = arrowScale.toFixed(1);
            if (currentViewMode === 'vector') updateVisualization();
        }
        
        function updateSliceDepth() {
            sliceDepth = parseFloat(document.getElementById('sliceDepth').value);
            document.getElementById('sliceDepthValue').textContent = sliceDepth.toFixed(1);
            if (currentViewMode === 'volume') updateVisualization();
        }
        
        function updateOpacity() {
            opacity = parseFloat(document.getElementById('opacity').value);
            document.getElementById('opacityValue').textContent = opacity.toFixed(1);
            if (currentViewMode === 'volume') updateVisualization();
        }
        
        function updateIsosurface() {
            isovalue = parseFloat(document.getElementById('isovalue').value);
            document.getElementById('isovalueValue').textContent = isovalue.toFixed(2);
            if (currentViewMode === 'isosurface') updateVisualization();
        }
        
        function resetView() {
            updateVisualization();
        }
        
        function toggleCube() {
            showCube = !showCube;
            if (currentViewMode === 'vector') updateVisualization();
        }
        
        // Start
        init();
    </script>
</body>
</html>

